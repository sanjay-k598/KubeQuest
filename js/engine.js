(function(){const deepClone=obj=>JSON.parse(JSON.stringify(obj));function initState(mission){const s=deepClone(mission.state);s._time=0;s._score=0;s._history=[];s._rolledBack=false;tick(s,0);return s}function tick(s,dt=1){s._time+=dt;for(const p of s.pods){const dep=s.deployments[p.owner];if(!dep){continue}if(p.status==='CrashLoopBackOff'&&/v2-bad/.test(dep.image)){p.ready=false}else if(p.status==='ImagePullBackOff'&&/typo/.test(dep.image)){p.ready=false}else if(p.status==='Pending'){const memNode=(s.nodes[0]?.allocatable?.memory)||4096;const req=(s.deployments[p.owner]?.resources?.requests?.memory)||256;p.ready=req<=memNode;p.status=p.ready?'Running':'Pending'}else{p.status='Running';p.ready=true}}for(const svc of s.services){const selKey=Object.keys(svc.selector||{})[0];if(selKey){const val=svc.selector[selKey];svc.endpoints=s.pods.filter(p=>p.ready&&(s.deployments[p.owner]?.labels?.[selKey]===val)).map((_,i)=>`10.0.0.${20+i}`)}}}function outGet(s,res){if(/^(pods|po)$/.test(res)){const lines=["NAME\tREADY\tSTATUS\tRESTARTS\tAGE"];for(const p of s.pods){const ready=p.ready?"1/1":"0/1";lines.push(`${p.name}\t${ready}\t${p.status}\t${p.restarts||0}\t${s._time}s`)}return lines.join('\n')}if(/^(deploy|deployment|deployments)$/.test(res)){const lines=["NAME\tREADY\tUP-TO-DATE\tAVAILABLE\tIMAGE"];for(const [name,d] of Object.entries(s.deployments)){const ready=s.pods.filter(p=>p.owner===name&&p.ready).length;lines.push(`${name}\t${ready}/${d.replicas}\t${d.replicas}\t${ready}\t${d.image}`)}return lines.join('\n')}if(/^(svc|service|services)$/.test(res)){const lines=["NAME\tTYPE\tCLUSTER-IP\tEXTERNAL-IP\tPORT(S)\tENDPOINTS"];for(const svc of s.services){lines.push(`${svc.name}\tClusterIP\t10.0.0.1\t<none>\t80/TCP\t${(svc.endpoints||[]).join(',')||"<none>"}`)}return lines.join('\n')}if(/^(nodes|no)$/.test(res)){const lines=["NAME\tSTATUS\tROLES\tAGE\tVERSION"];for(const n of s.nodes){lines.push(`${n.name}\t${n.ready?"Ready":"NotReady"}\tworker\t${s._time}s\tv1.27`)}return lines.join('\n')}return"resource not implemented in demo"}function outDescribe(s,res,name){if(res.startsWith('pod')){const p=s.pods.find(x=>x.name===name)||s.pods[0];const ev=(p.status==='CrashLoopBackOff')?"Back-off restarting failed container":(p.status==='ImagePullBackOff')?"Failed to pull image: not found":(p.status==='Pending')?(p.reason||"Insufficient resources") :"Started container";return`Name: ${p.name}
Owner: ${p.owner}
Status: ${p.status}
Ready: ${p.ready}
Events:
  ${ev}`}if(res.startsWith('deploy')){const d=s.deployments[name]||Object.values(s.deployments)[0];return`Name: ${name}
Replicas: ${d.replicas}
Image: ${d.image}
Selector: ${JSON.stringify(d.labels)}`}if(res.startsWith('svc')){const svc=s.services.find(x=>x.name===name)||s.services[0];return`Name: ${svc.name}
Selector: ${JSON.stringify(svc.selector)}
Endpoints: ${(svc.endpoints||[]).join(',')||"<none>"}`}return"describe not implemented"}function runCmd(s,ast,mission){switch(ast.cmd){case'help':return{text:"kubectl get pods|deploy|svc|nodes • describe POD|DEPLOY|SVC <name> • logs POD • set image deploy/<d> <c>=<img:tag> • rollout undo deploy/<d> • scale deploy/<d> --replicas=N • patch deploy/<d> -p '{...}' • clear",score:0};case'clear':return{clear:true,text:"",score:0};case'get':return{text:outGet(s,ast.res),score:+5};case'describe':return{text:outDescribe(s,ast.res,ast.name),score:+10};case'logs':return{text:"ERROR: app failed to bind port (bad config)".repeat(ast.name?1:0)||"logs: specify a pod",score:ast.name?+10:0};case'setimage':{if(ast.target?.startsWith('deploy/')||ast.target?.startsWith('deployment/')){const name=ast.target.split('/')[1];if(s.deployments[name]){s.deployments[name].image=ast.image||s.deployments[name].image;s.pods=s.pods.filter(p=>p.owner!==name);for(let i=0;i<s.deployments[name].replicas;i++){s.pods.push({name:`${name}-xxxx${i}`,owner:name,status:'Running',ready:true,restarts:0})}tick(s,1);return{text:`deployment.apps/${name} image updated`,score:+30}}}return{text:"target not found",score:0}}case'rollout':{const name=(ast.target||'').split('/')[1];if(ast.action==='undo'&&s.deployments[name]){s.deployments[name].image="acme/web:v1";s._rolledBack=true;s.pods=s.pods.filter(p=>p.owner!==name);for(let i=0;i<s.deployments[name].replicas;i++){s.pods.push({name:`${name}-roll-${i}`,owner:name,status:'Running',ready:true,restarts:0})}return{text:`rollback successful on ${name}`,score:+35}}if(ast.action==='status'){const ready=s.pods.filter(p=>p.ready).length;return{text:`rollout status: ${ready} pods Ready`,score:+5}return{text:"unsupported rollout action",score:0}}return{text:"unsupported rollout action",score:0}}case'scale':{const name=(ast.target||'').split('/')[1];if(s.deployments[name]&&Number.isFinite(ast.replicas)){s.deployments[name].replicas=ast.replicas;s.pods=s.pods.filter(p=>p.owner!==name);for(let i=0;i<ast.replicas;i++){s.pods.push({name:`${name}-sc-${i}`,owner:name,status:'Running',ready:true,restarts:0})}return{text:`scaled ${name} to ${ast.replicas}`,score:+15}}return{text:"scale failed",score:0}}case'patch':{const name=(ast.target||'').split('/')[1];if(s.deployments[name]){try{const patch=JSON.parse(ast.json||"{}");const req=patch?.spec?.template?.spec?.containers?.[0]?.resources?.requests?.memory;if(req){const v=String(req).toLowerCase().endsWith('mi')?parseInt(req,10):parseInt(req,10);s.deployments[name].resources={requests:{memory:v}};s.pods=s.pods.filter(p=>p.owner!==name);for(let i=0;i<s.deployments[name].replicas;i++){const ok=v<=((s.nodes[0]?.allocatable?.memory)||4096);s.pods.push({name:`${name}-pt-${i}`,owner:name,status:ok?'Running':'Pending',ready:ok})}return{text:`patched ${name} requests.memory=${req}`,score:+25}}}catch(e){}return{text:"patch applied",score:+10}}return{text:"target not found",score:0}}case'text':return{text:ast.text,score:0};default:return{text:'unknown command',score:0}}}window.Engine={initState,runCmd,tick};})();